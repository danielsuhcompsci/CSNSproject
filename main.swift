import Foundation

let lowerCases : [Character] = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w" , "x", "y", "z"] // 0 to 25

let upperCases : [Character] = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V" ,"W", "X", "Y", "Z"]

let lowercaseLetterSet : Set<Character> = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w" , "x", "y", "z"]

let uppercaseLetterSet : Set<Character> = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V" ,"W", "X", "Y", "Z"]

let valueToSymbol = [100: " ", 101: ",", 102: ".", 103: "?", 104: "!"]

func power(_ n:Int,_ exp:Int) -> Int{
    var r = n
    let base = n
    
    if exp == 1{
        return r
    } else {
        for _ in 2 ... exp{
            r *= base
        }
    }

    return r
}

func getValue(letter: Character) -> Int{    
    switch letter{
    case " ":
        return 100
    case ",":
        return 101
    case ".":
        return 102
    case "?":
        return 103
    case "!":
        return 104
    default:
        if lowercaseLetterSet.contains(letter){
            for i in 0 ..< lowerCases.count{  // i = 0, 1, 2, 3, 4 ... 26(lowerCases.count)
                if letter == lowerCases[i]{
                    return i
                }
            }                           
        } else {
            for i in 0 ..< upperCases.count{
                if letter == upperCases[i]{
                    return i + 26
                }
            }
        }
    }
    return 63
}


func isPrime(_ number:Int) -> Bool{
    let isEven = number % 2 == 0
    if number == 2{
        return true
    } else if isEven || number == 1{
        return false
    } else {
        for i in 3 ..< number{
            if number % i == 0{
                return false
            }              
        }
    }
    
    return true
}    

func gcd(_ input1:Int,_ input2:Int) -> Int{
    var p = input1
    var q = input2

    var remainder = p % q

    while remainder != 0{
        p = q
        q = remainder
        remainder = p % q
    }

    return q    
}

// 1 < e < phi; gcd(e, phi) = 1
func findE(phi:Int) -> Int{
    for i in 2 ..< phi{
        let e = i
        if gcd(e, phi) == 1{
            return e
        }
    }

    return 1 // if returns 1, error
}
//e*d(mod a) = 1 or d = (1/e)(mod a)
// d = (1 + k*phi) / e | k = mod

func findD(phi:Int, e:Int) -> Int{    // p = phi, q = e    
    var k = 0
    var d : Double

    repeat{        
        k += 1
        d = (1.0 + Double(k) * Double(phi)) / Double(e)
    }while d.truncatingRemainder(dividingBy:1) != 0

    return Int(d)
}

func generateRandomPrime() -> Int{
    var n : Int

    repeat{
        n = Int.random(in:0 ... 10000)
    } while !isPrime(n)

    return n
}

func RSA_Algorithm(){    
    let p = generateRandomPrime()
    print("Generating random prime(p)...")
    print("p = \(p)")
    
    let q = generateRandomPrime()
    print("Generating random prime(q)...")
    print("q = \(q)")
    
    let n = p * q
    print("Generating n...")   
    
    let phi = (p - 1)*(q - 1)
    print("Generating phi...")
    print("phi = \(phi)")
    
    let e = findE(phi:phi)
    let d = findD(phi:phi, e:e)

    print("The public key is: (n: \(n),e: \(e)).")
    print("The private key is: (d: \(d)).")

    print()
    print("Please input a message to encrypt:")
    
    if let message = readLine(){

        var messageAscii = "" // message in ascii form
        var cipherNumeric = "" // cipher in ascii form
        
        for char in message{
            // Creates message in ascii with spaces
            let charAscii = Int(char.asciiValue!)            
            messageAscii += String(charAscii)

            //Adds Space
            let lastChar = message.last
            if char != lastChar{
                messageAscii += " "
            }

            //Creates cipher value of charAscii with RSA
            let cipherValue = power(charAscii, e) % n


            //Adds to cipher in numeric form
            cipherNumeric += String(cipherValue)

            //Adds Space
            if char != lastChar{
                cipherNumeric += " "
            }
            
            // if lowercaseLetterSet.contains(char){
            //     let charValue = getValue(letter:char)
            //     cipherText += String(power(charValue, e) % n)
            // } else if uppercaseLetterSet.contains(char){
            //     let charValue = getValue(letter:char)
            //     cipherText += String(power(charValue, e) % n)
            // } else if let number = Int(String(char)){
            //     cipherText += String(power(number, e) % n)
            // } else {
            //     let symbolValue = getValue(letter: char)
            //     cipherText += String(power(symbolValue, e) % n)
            // }
        }

        print("Message in Numeric Form: \(messageAscii)")
        print("Ciphertext in Numeric Form: \(cipherNumeric)")
                                
        var decryptedText = ""

        //Makes array of cipher components
        let cipherValues = cipherNumeric.components(separatedBy: " ")

        for component in cipherValues{
            //Sets string component to integer
            guard let cipherValue = Int(component) else { fatalError("cipherText component invalid, not integer; Invalid message?")}

            //Decrypts cipherValue
            let decryptedValue = power(cipherValue, d) % n

            //Converts decryptedValue, which should be an asciiValue 
            decryptedText += String(UnicodeScalar(decryptedValue)!)
        }
                  

        print("Decrypted text is: \(decryptedText)")
    }
    
    //m^e modN = c -> Formula for encryption
    //c^d modN = m -> Formula for decryption

}



//AES Algorithm


//Shortcut Tables for AES implementation:

let s_box = [99 ,124 ,119 ,123 ,242 ,107 ,111 ,197 ,48 ,1 ,103 ,43 ,254 ,215 ,171 ,118
            ,202 ,130 ,201 ,125 ,250 ,89 ,71 ,240 ,173 ,212 ,162 ,175 ,156 ,164 ,114 ,192
            ,183 ,253 ,147 ,38 ,54 ,63 ,247 ,204 ,52 ,165 ,229 ,241 ,113 ,216 ,49 ,21
            ,4 ,199 ,35 ,195 ,24 ,150 ,5 ,154 ,7 ,18 ,128 ,226 ,235 ,39 ,178 ,117
            ,9 ,131 ,44 ,26 ,27 ,110 ,90 ,160 ,82 ,59 ,214 ,179 ,41 ,227 ,47 ,132
            ,83 ,209 ,0 ,237 ,32 ,252 ,177 ,91 ,106 ,203 ,190 ,57 ,74 ,76 ,88 ,207
            ,208 ,239 ,170 ,251 ,67 ,77 ,51 ,133 ,69 ,249 ,2 ,127 ,80 ,60 ,159 ,168
            ,81 ,163 ,64 ,143 ,146 ,157 ,56 ,245 ,188 ,182 ,218 ,33 ,16 ,255 ,243 ,210
            ,205 ,12 ,19 ,236 ,95 ,151 ,68 ,23 ,196 ,167 ,126 ,61 ,100 ,93 ,25 ,115
            ,96 ,129 ,79 ,220 ,34 ,42 ,144 ,136 ,70 ,238 ,184 ,20 ,222 ,94 ,11 ,219
            ,224 ,50 ,58 ,10 ,73 ,6 ,36 ,92 ,194 ,211 ,172 ,98 ,145 ,149 ,228 ,121
            ,231 ,200 ,55 ,109 ,141 ,213 ,78 ,169 ,108 ,86 ,244 ,234 ,101 ,122 ,174 ,8
            ,186 ,120 ,37 ,46 ,28 ,166 ,180 ,198 ,232 ,221 ,116 ,31 ,75 ,189 ,139 ,138
            ,112 ,62 ,181 ,102 ,72 ,3 ,246 ,14 ,97 ,53 ,87 ,185 ,134 ,193 ,29 ,158
            ,225 ,248 ,152 ,17 ,105 ,217 ,142 ,148 ,155 ,30 ,135 ,233 ,206 ,85 ,40 ,223
            ,140 ,161 ,137 ,13 ,191 ,230 ,66 ,104 ,65 ,153 ,45 ,15 ,176 ,84 ,187 ,22]

let inv_s_box = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251,
                 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203,
                 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78,
                 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37,
                 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146,
                 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132,
                 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6,
                 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107,
                 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115,
                 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110,
                 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27,
                 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244,
                 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95,
                 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239,
                 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97,
                 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]

let mulBy2 = [0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
              0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
              0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
              0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
              0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
              0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
              0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
              0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
              0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
              0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
              0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
              0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
              0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
              0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
              0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
              0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5]

let mulBy3 = [0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
              0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
              0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
              0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
              0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
              0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
              0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
              0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
              0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
              0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
              0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
              0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
              0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
              0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
              0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
              0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a]

let rcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
            0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
            0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
            0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
            0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
            0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
            0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
            0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
            0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
            0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
            0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
            0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 
0x01, 0x02, 0x04,
            0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
            0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb]

let mulBy9 = [0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
              0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
              0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
              0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
              0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
              0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
              0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
              0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
              0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
              0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
              0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
              0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
              0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
              0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
              0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
              0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46]

let mulBy11 = [0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
               0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
               0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
               0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
               0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
               0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
               0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
               0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
               0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
               0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
               0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
               0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
               0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
               0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
               0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
               0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3]

let mulBy13 = [0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
               0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
               0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
               0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
               0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
               0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
               0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
               0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
               0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
               0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
               0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
               0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
               0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
               0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
               0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
               0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97]

let mulBy14 = [0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
               0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
               0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
               0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
               0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
               0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
               0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
               0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
               0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
               0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
               0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
               0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
               0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
               0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
               0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
               0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d]

let key = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13, 14, 15, 16]

func KeyExpansionCore(a:inout [Int], i: Int){
    print("Entering KeyExpansionCore()")
    print("Temp: \(a)")
    //Rotate left:  0 1 2 3 -> 1 2 3 0
    let t = a[0]
    a[0] = a[1]
    a[1] = a[2]
    a[2] = a[3]
    a[3] = t

    print("Rotated left: \(a)")
    
    // S-Box
    a[0] = s_box[a[0]]; a[1] = s_box[a[1]]; a[2] = s_box[a[2]]; a[3] = s_box[a[3]]

    print("Substituted: \(a)")

    //RCon(Round Constant) step
    a[0] ^= rcon[i]
    print("After Rcon: \(a)")
}

func KeyExpansion(inputKey: [Int], expandedKeys:inout [Int]){
    // First 16 bytes should be the original key
    for i in 0 ..< 16{
        expandedKeys[i] = inputKey[i]
    }

    //Variables:
    var bytesGenerated = 16 //Generated 16 bytes already
    var rconIteration = 1 // rcon i begins at 1
    var temp = [Int](repeating: 0, count: 16) // Temp storage for core


    while bytesGenerated < 176{
        //Copy previous four bytes to a temp array
        for i in 0 ..< 4{
            temp[i] = expandedKeys[(i + bytesGenerated) - 4]            
        }

        //Perform the core once for each 16 byte key, happens on first word(4 bytes) of key
        if (bytesGenerated % 16) == 0{
            KeyExpansionCore(a: &temp, i: rconIteration)
            rconIteration += 1
            print("The temp at rconIteration \(rconIteration) is \(temp)")
        }

        //XOR temp with [bytesGenerated - 16], store in expandedKeys
        for i in 0 ..< 4{
            expandedKeys[bytesGenerated] = expandedKeys[(bytesGenerated - 16) ^ temp[i]]
            bytesGenerated += 1 //Generates 4 bytes in total
        }
    }

}

//var expandedKeys = [Int](repeating: 0, count: 176)

//KeyExpansion(inputKey: key, expandedKeys: &expandedKeys)

func SubBytes(state:inout [Int]) {
    for i in 0 ..< 16{
        state[i] = s_box[state[i]]
    }

}

func invSubBytes(state:inout [Int]){
    for i in 0 ..< 16{
        state[i] = inv_s_box[state[i]]
    }
}

func ShiftRows(state:inout [Int]) {
    var temp = [Int]()

    temp[0] = state[0]
    temp[1] = state[5]
    temp[2] = state[10]
    temp[3] = state[15]

    temp[4] = state[4]
    temp[5] = state[9]
    temp[6] = state[14]
    temp[7] = state[3]

    temp[8] = state[8]
    temp[9] = state[13]
    temp[10] = state[2]
    temp[11] = state[7]

    temp[12] = state[12]
    temp[13] = state[1]
    temp[14] = state[6]
    temp[15] = state[11]

    for i in 0 ..< 16{
        state[i] = temp[i]
    }
}

func invShiftRows(state:inout [Int]){
    var temp = [Int]()

    temp[0] = state[0]
    temp[1] = state[13]
    temp[2] = state[10]
    temp[3] = state[7]

    temp[4] = state[4]
    temp[5] = state[1]
    temp[6] = state[14]
    temp[7] = state[11]

    temp[8] = state[8]
    temp[9] = state[5]
    temp[10] = state[2]
    temp[11] = state[15]

    temp[12] = state[12]
    temp[13] = state[9]
    temp[14] = state[6]
    temp[15] = state[3]

    for i in 0 ..< 16{
        state[i] = temp[i]
    }    
}

   ////// Conversion: Matrix
   // 2 3 1 1
   // 1 2 3 1
   // 1 1 2 3
   // 3 1 1 2

func MixColumns(state:inout [Int]){
    var temp = [Int]()

    //Matrix multiplication with conversion matrix and column of state array

    // Positions 0 - 3
    temp[0] = (mulBy2[state[0]] ^ mulBy3[state[1]] ^ state[2] ^ state[3])
    temp[1] = (state[0] ^ mulBy2[state[1]] ^ mulBy3[state[2]] ^ state[3])
    temp[2] = (state[0] ^ state[1] ^ mulBy2[state[2]] ^ mulBy3[state[3]])
    temp[3] = (mulBy3[state[0]] ^ state[1] ^ state[2] ^ mulBy2[state[3]])

    // Positions 4 - 7
    temp[4] = (mulBy2[state[4]] ^ mulBy3[state[5]] ^ state[6] ^ state[7])
    temp[5] = (state[4] ^ mulBy2[state[5]] ^ mulBy3[state[6]] ^ state[7])
    temp[6] = (state[4] ^ state[5] ^ mulBy2[state[6]] ^ mulBy3[state[7]])
    temp[7] = (mulBy3[state[4]] ^ state[5] ^ state[6] ^ mulBy2[state[7]])

    //Positions 8 - 11
    temp[8] = (mulBy2[state[8]] ^ mulBy3[state[9]] ^ state[10] ^ state[11])
    temp[9] = (state[8] ^ mulBy2[state[9]] ^ mulBy3[state[10]] ^ state[11])
    temp[10] = (state[8] ^ state[9] ^ mulBy2[state[10]] ^ mulBy3[state[11]])
    temp[11] = (mulBy3[state[8]] ^ state[9] ^ state[10] ^ mulBy2[state[11]])

    //Positions 12 - 15
    temp[12] = (mulBy2[state[12]] ^ mulBy3[state[13]] ^ state[14] ^ state[15])
    temp[13] = (state[12] ^ mulBy2[state[13]] ^ mulBy3[state[14]] ^ state[15])
    temp[14] = (state[12] ^ state[13] ^ mulBy2[state[14]] ^ mulBy3[state[15]])
    temp[15] = (mulBy3[state[12]] ^ state[13] ^ state[14] ^ mulBy2[state[15]])

    //Copy contents of temp back to state

    for i in 0 ..< 16{
        state[i] = temp[i]
    }
}

func invMixColumns(state:inout [Int]){
    var temp = [Int]()

    //Matrix multiplication with conversion matrix and column of state array

    // Positions 0 - 3
    temp[0] = (mulBy14[state[0]] ^ mulBy11[state[1]] ^ mulBy13[state[2]] ^ mulBy9[state[3]])
    temp[1] = (mulBy9[state[0]] ^ mulBy14[state[1]] ^ mulBy11[state[2]] ^ mulBy13[state[3]])
    temp[2] = (mulBy13[state[0]] ^ mulBy9[state[1]] ^ mulBy14[state[2]] ^ mulBy11[state[3]])
    temp[3] = (mulBy11[state[0]] ^ mulBy13[state[1]] ^ mulBy9[state[2]] ^ mulBy14[state[3]])

    // Positions 4 - 7
    temp[4] = (mulBy14[state[4]] ^ mulBy11[state[5]] ^ mulBy13[state[6]] ^ mulBy9[state[7]])
    temp[5] = (mulBy9[state[4]] ^ mulBy14[state[5]] ^ mulBy11[state[6]] ^ mulBy13[state[7]])
    temp[6] = (mulBy13[state[4]] ^ mulBy9[state[5]] ^ mulBy14[state[6]] ^ mulBy11[state[7]])
    temp[7] = (mulBy11[state[4]] ^ mulBy13[state[5]] ^ mulBy9[state[6]] ^ mulBy14[state[7]])

    //Positions 8 - 11
    temp[8] = (mulBy14[state[8]] ^ mulBy11[state[9]] ^ mulBy13[state[10]] ^ mulBy9[state[11]])
    temp[9] = (mulBy9[state[8]] ^ mulBy14[state[9]] ^ mulBy11[state[10]] ^ mulBy13[state[11]])
    temp[10] = (mulBy13[state[8]] ^ mulBy9[state[9]] ^ mulBy14[state[10]] ^ mulBy11[state[11]])
    temp[11] = (mulBy11[state[8]] ^ mulBy13[state[9]] ^ mulBy9[state[10]] ^ mulBy14[state[11]])

    //Positions 12 - 15
    temp[12] = (mulBy14[state[12]] ^ mulBy11[state[13]] ^ mulBy13[state[14]] ^ mulBy9[state[15]])
    temp[13] = (mulBy9[state[12]] ^ mulBy14[state[13]] ^ mulBy11[state[14]] ^ mulBy13[state[15]])
    temp[14] = (mulBy13[state[12]] ^ mulBy9[state[13]] ^ mulBy14[state[14]] ^ mulBy11[state[15]])
    temp[15] = (mulBy11[state[12]] ^ mulBy13[state[13]] ^ mulBy9[state[14]] ^ mulBy14[state[15]])

    //Copy contents of temp back to state
    for i in 0 ..< 16{
        state[i] = temp[i]
    }
}

func AddRoundKey(state:inout [Int], roundKey: ArraySlice<Int>){

    for i in 0 ..< 16{
        state[i] ^= roundKey[i]
    }
}    

var lettersToNumbers = [String: Int]()

func AES_Algorithm(message:inout String, key: [Int]){        
    var charsAdded = 0
    while message.count < 16{
        message += "0"
        charsAdded += 1
    }
    
    var messageAscii = [Int]()    
    for char in message{
        let charAscii = char.asciiValue
        let int = Int(charAscii!)

        messageAscii.append(int)
    }

    var state = [Int]()
    for i in 0 ..< 16{

        state[i] = messageAscii[i]

    }

    let numberOfRounds = 9;

    var expandedKeys = [Int]()

    let zeroKey = key[0 ... 15]
    KeyExpansion(inputKey:key, expandedKeys: &expandedKeys)
    AddRoundKey(state: &state, roundKey: zeroKey)

    for i in 1 ... numberOfRounds{
        SubBytes(state: &state)
        ShiftRows(state: &state)
        MixColumns(state: &state)

        let roundKey = expandedKeys[(16 * i) ..< (16 * (i + 1))]
        AddRoundKey(state: &state, roundKey: roundKey)
   } 

    //Final Round
    SubBytes(state: &state)
    ShiftRows(state: &state)        

    let finalKey = expandedKeys[160 ... 175]
    AddRoundKey(state: &state, roundKey: finalKey)

     
}    

///////////////////////////
//Caesar Cipher
///////////////////////////

func shiftValue(letterValue: Int,shiftBy: Int, direction: String) -> Int{
    var value = letterValue

    switch direction{
        
    case "L":
        
        if letterValue < 26{
            for _ in 1 ... shiftBy{
                if value == 0{
                    value = 25
                } else {
                    value -= 1
                }
            }
        } else {
            for _ in 1 ... shiftBy{
                if value == 26{
                    value = 51
                } else {
                    value -= 1
                }
            }
        }
    case "R":
        if letterValue < 26{
            for _ in 1 ... shiftBy{
                if value == 25{
                    value = 0
                } else {
                    value += 1
                }
            }
        } else {
            for _ in 1 ... shiftBy{
                if value == 51{
                    value = 26
                } else {
                    value += 1
                }
            }
        }
    default:
        fatalError("Invalid Input for direction")
    }

    return value
}



func makeShiftedValueArray(_ message:String,_ shiftBy: Int,_ direction: String) -> [Int]{
    var shiftedValueArray = [Int]() //////////// Make array of shiftedValues
    
    for letter in message{
        precondition(getValue(letter:letter) != 63, "Invalid Input for Caesar Cipher")
        
        if lowercaseLetterSet.contains(letter){ // if letter is lowercase

            let lowercaseValue = getValue(letter: letter)
            let shiftedValue = shiftValue(letterValue: lowercaseValue, shiftBy: shiftBy, direction: direction)
            shiftedValueArray.append(shiftedValue)
            
        } else if uppercaseLetterSet.contains(letter){ // else if letter is upper case

            let uppercaseValue = getValue(letter: letter)
            let shiftedValue = shiftValue(letterValue: uppercaseValue, shiftBy: shiftBy, direction: direction)
            shiftedValueArray.append(shiftedValue)                        
            
        } else {                         // else it is a symbol ("!", "?", etc) 
            let symbolValue = getValue(letter: letter)
            shiftedValueArray.append(symbolValue)
        }
    }

    return shiftedValueArray
}

func makeCipherText(_ shiftedValueArray: [Int]) -> String{
    var cipherText = "" ///////////////// Make Cipher text

    for value in shiftedValueArray{  
        if value < 26{

            let lowercaseLetter = lowerCases[value]
            cipherText.append(lowercaseLetter)
            
        } else if value <= 51 && value >= 26 {

            let uppercaseLetter = upperCases[value - 26] // Bias of 26
            cipherText.append(uppercaseLetter)
            
        } else {           

            let cipherSymbol = valueToSymbol[value]
            cipherText.append(cipherSymbol!)
            
        }
    }        

    return cipherText
}

func CaesarCipher(message: String, shiftBy: Int, direction: String){        
    precondition(direction == "L" || direction == "R", "Invalid input for direction parameter")

    let shiftedValueArray = makeShiftedValueArray(message, shiftBy, direction)

    let cipherText = makeCipherText(shiftedValueArray)

    print("Message: '\(message)'")
    print("Ciphertext: \(cipherText) (Shifted by: \(shiftBy))")
}



func main(){
    print("Which algorithm would you like to use?")
    print("Type 'RSA' for the RSA Algorithm, 'C' for the Caesar Cipher, and 'AES' for the AES Algorithm, or CTRL^C to exit")

    if let line = readLine(){

        switch line{
        case "C":
            var answer : String?

            repeat{
                print("Please type the message you would like to encrypt.")
                print("Only available symbols: ',' '.' '?', '!'")
                
                let line1 = readLine()
                
                if line1 != nil{
                    print()
                    print("What index would you like to shift by?")
                    print("Type an integer only")

                    
                }

                let message = line1!
                
                let line2 = readLine()
                
                if line2 != nil{
                    print()
                    print("What direction would you like to shift?")
                    print("Enter 'L', or 'R':")
                }

                guard let shiftBy = Int(line2!) else { fatalError("Invalid input for direction")}
                let direction = readLine()

                print()
                CaesarCipher(message: message, shiftBy: shiftBy, direction: direction!)

                print()
                print("Would you like to use the Caesar cipher again?")
                print("Please type 'yes' or 'no':")
                
                answer = readLine()
                print()
            }while answer! == "yes"
        case "RSA":
            RSA_Algorithm()
        case "AES":
//            var message = ""
  //          if message != nil(){
    //            AES_Algorithm(message: &message, key:key )
    //      }
            print("AES does not work just yet")
        default:
            fatalError("Invalid Input for CategoryName")
        }
    }
}

main()
